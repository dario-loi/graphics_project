<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a202c;
        }

        #canvas-container {
            width: 75vw;
            height: 100vh;
        }

        #webgl-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #info {
            width: 25vw;
            height: 100vh;
            background-color: #2d3748;
            color: #fff;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #fps-counter {
            font-size: 2rem;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="webgl-canvas"></canvas>
    </div>
    <div id="info" class="flex flex-col justify-center items-center">
        <div id="fps-counter">FPS: 0</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="./common.js"></script>

    <script>
        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert("WebGL 2.0 isn't available in your browser.");
        }

        // enable MSAA

        fbm_drawer = new FBM(gl);

        // backface culling
        // gl.enable(gl.CULL_FACE);

        // Vertex shader program
        const vsSource = `#version 300 es
            in vec4 aVertexPosition;
            in vec4 aVertexUv;
            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            out lowp vec4 vColor;
            out highp vec4 vPosition;
            out highp vec2 vUv;
            out highp float vHeight;

            #define EXAGGERATION 3.0

            uniform sampler2D uNoiseSampler;

            void main(void) {

                float h = texture(uNoiseSampler, aVertexUv.xy).r;

                vec4 deformed = (uModelMatrix * aVertexPosition) + vec4(0.0, EXAGGERATION * h, 0.0, 0.0);

                vPosition = uViewMatrix * deformed;
                gl_Position = uProjectionMatrix * vPosition;

                vColor = vec4(1.0, 1.0, 1.0, 1.0);
                vUv = aVertexUv.xy;
                vHeight = h;
            }
        `;

        // Fragment shader program
        const fsSource = `#version 300 es
            precision highp float;

            uniform sampler2D uSampler;
            uniform sampler2D uNoiseSampler;
            uniform sampler2D uNormalSampler;
            uniform sampler2D uOcclusionSampler;
            uniform sampler2D uRoughnessSampler;

            uniform samplerCube uSkybox;

            uniform vec2 uOffset;
            uniform vec4 uCameraPosition;

            in lowp vec4 vColor;
            in highp vec4 vPosition;
            in highp vec2 vUv;
            in highp float vHeight;

            out vec4 fragColor;

            // coming from the top right of the screen
            const highp vec3 sun_dir = normalize(vec3(1.0, 1.0, 1.0));

            const highp float ambient = 0.2;
            const highp float ambient_reflection = 0.4;

            void main(void) {

                vec3 dx = dFdx(vPosition.xyz);
                vec3 dy = dFdy(vPosition.xyz);

                vec3 normal = normalize(cross(dx, dy));

                // TBN
                vec3 T = normalize(dx);
                vec3 B = normalize(dy);
                vec3 N = normalize(normal);

                mat3 TBN = mat3(T, B, N);

                normal = texture(uNormalSampler, vUv).xyz;
                normal = normalize(normal * 2.0 - 1.0);

                normal = normalize(TBN * normal);

                float occlusion = texture(uOcclusionSampler, vUv).r;

                float diffuse = max(dot(normal, sun_dir), 0.0);

                vec3 view_dir = normalize(uCameraPosition.xyz - vPosition.xyz);
                vec3 half_dir = normalize(sun_dir + view_dir);
                float roughness = texture(uRoughnessSampler, vUv).r;

                float specular = pow(max(dot(normal, half_dir), 0.0), 16.0) * (1.0 - roughness);

                // ambient light from the skybox

                vec3 R = reflect(view_dir, normal);
                vec3 skybox_color = texture(uSkybox, R).rgb * ambient_reflection;


                float light = (ambient + diffuse + specular);

                fragColor = vec4((texture(uSampler, vUv).rgb + skybox_color * light) * occlusion, 1.0);
            }
        `;

        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

        const programInfo = {
            program: shaderProgram,
            attr_locations: {
                v_pos: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                v_uv: gl.getAttribLocation(shaderProgram, 'aVertexUv'),
            },
            u_locations: {
                proj_mat: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                view_mat: gl.getUniformLocation(shaderProgram, 'uViewMatrix'),
                model_mat: gl.getUniformLocation(shaderProgram, 'uModelMatrix'),
                offset: gl.getUniformLocation(shaderProgram, 'uOffset'),
            },
            u_texture: gl.getUniformLocation(shaderProgram, 'uSampler'),
            u_noise_texture: gl.getUniformLocation(shaderProgram, 'uNoiseSampler'),
            u_normals_texture: gl.getUniformLocation(shaderProgram, 'uNormalSampler'),
            u_occlusion_texture: gl.getUniformLocation(shaderProgram, 'uOcclusionSampler'),
            u_cube_texture: gl.getUniformLocation(shaderProgram, 'uSkybox'),
        };



        // INIT "GLOBALS"

        let chunks = [];
        let last_time = 0.0;

        let camera = {
            yaw: 0.0,
            pitch: 0.0,
            sensitivity: 0.002,
            is_locked: false,
            delta_x: 0.0,
            delta_y: 0.0,
            position: vec3.fromValues(0.0, 0.0, -10.0),
            up: vec3.fromValues(0.0, 1.0, 0.0),
            front: vec3.fromValues(0.0, 0.0, 1.0),
            speed: 0.001,
            sprint_multiplier: 2.5,
            keys: {
                "w": false,
                "a": false,
                "s": false,
                "d": false,
                "shift": false,
                "space": false,
                "ctrl": false
            }
        };




        // DECLARE PERIODIC EVENTS

        // schema: {name: string, interval: number, func: function}
        lambdas = [
            {
                "name": "spawn_chunks",
                "interval": 2500.0, // ms
                "offset": 0.0, // ms
                "func": function () {
                    console.log("Spawning chunks");
                }
            },
            {
                "name": "despawn_chunks",
                "interval": 2500.0, // ms
                "offset": 1250.0, // ms
                "func": function () {
                    console.log("Despawning chunks");
                }
            },
        ];

        // for each lambda, after offset time, register the lambda to be called every interval time
        // for (let lambda of lambdas) {
        //     setTimeout(function () {
        //         setInterval(lambda.func, lambda.interval);
        //     }, lambda.offset);
        // }

        // DECLARE EVENT LISTENERS

        listeners = [
            {
                "name": "window_resize",
                "exec_first": true,
                "trigger": "resize",
                "func": function () {
                    const displayWidth = canvas.clientWidth;
                    const displayHeight = canvas.clientHeight;

                    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                        canvas.width = displayWidth;
                        canvas.height = displayHeight;
                        gl.viewport(0, 0, canvas.width, canvas.height);
                    }
                }
            },
            {
                "name": "mouse_lock",
                "exec_first": false,
                "trigger": "click",
                "func": function () {
                    canvas.requestPointerLock();
                }
            },
            {
                "name": "mouse_unlock",
                "exec_first": false,
                "trigger": "pointerlockchange",
                "func": function () {
                    if (document.pointerLockElement === canvas) {
                        camera.is_locked = true;
                    } else {
                        camera.is_locked = false;
                    }
                }
            },
            {
                "name": "mouse_move",
                "exec_first": false,
                "trigger": "mousemove",
                "func": function (event) {
                    if (camera.is_locked) {
                        camera.delta_x = event.movementX;
                        camera.delta_y = -event.movementY;
                    }
                }
            },
            {
                "name": "handle_keydown",
                "exec_first": false,
                "trigger": "keydown",
                "func": function (event) {

                    key = event.key.toLowerCase();
                    camera.keys[key] = true;
                }
            }, {
                "name": "handle_keyup",
                "exec_first": false,
                "trigger": "keyup",
                "func": function (event) {
                    key = event.key.toLowerCase();
                    camera.keys[key] = false;
                }
            }
        ]

        // inject event listeners
        for (let listener of listeners) {
            if (listener.exec_first) {
                listener.func();
            }
            window.addEventListener(listener.trigger, listener.func);
        }

        // PREP NOISE TARGET

        let noise_tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, noise_tex);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            256,
            256,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            null
        );

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);



        // vertices 3
        // uvs 2
        // normals 3
        buffers = gen_quad(gl, 512);

        // RENDER LOOP
        let grass = new ImageTexture2D(gl, "textures/grass_diffuse.png", {
            wrap_s: gl.REPEAT,
            wrap_t: gl.REPEAT,
            generate_mipmaps: true,
            anisotropy: 4
        });

        let grass_normals = new ImageTexture2D(gl, "textures/grass_normal.png", {
            wrap_s: gl.REPEAT,
            wrap_t: gl.REPEAT,
            generate_mipmaps: true,
            anisotropy: 4
        });

        let grass_occlusion = new ImageTexture2D(gl, "textures/grass_occlusion.png", {
            wrap_s: gl.REPEAT,
            wrap_t: gl.REPEAT,
            generate_mipmaps: true,
            anisotropy: 4
        });

        skybox = new Skybox(gl, new Cubemap(gl, [
            "skybox/right.jpg",
            "skybox/left.jpg",
            "skybox/top.jpg",
            "skybox/bottom.jpg",
            "skybox/front.jpg",
            "skybox/back.jpg",
        ]));

        function render() {

            let time = performance.now();
            let delta_time = time - last_time;

            last_time = time;

            x_pos = 0.0;

            fbm_drawer.sample_fbm(
                gl, noise_tex, 42, 256, 256, x_pos, 0.0
            )

            // update view matrix

            let speed = camera.speed;
            if (camera.keys["shift"]) {
                speed *= camera.sprint_multiplier;
            }
            speed *= delta_time;

            if (camera.keys["w"]) {
                camera.position = vec3.add(camera.position, camera.position, vec3.scale(vec3.create(), camera.front, speed));
            }
            if (camera.keys["s"]) {
                camera.position = vec3.sub(camera.position, camera.position, vec3.scale(vec3.create(), camera.front, speed));
            }
            if (camera.keys["a"]) {
                camera.position = vec3.sub(camera.position, camera.position, vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), camera.front, camera.up)), speed));
            }
            if (camera.keys["d"]) {
                camera.position = vec3.add(camera.position, camera.position, vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), camera.front, camera.up)), speed));
            }
            if (camera.keys[" "]) {
                camera.position = vec3.add(camera.position, camera.position, vec3.scale(vec3.create(), camera.up, speed));
            }
            if (camera.keys["control"]) {
                camera.position = vec3.sub(camera.position, camera.position, vec3.scale(vec3.create(), camera.up, speed));
            }
            if (camera.keys["r"]) {
                camera.position = vec3.fromValues(0.0, 0.0, -10.0);
            }


            if (camera.is_locked) {
                camera.yaw += camera.delta_x * camera.sensitivity;
                camera.pitch += camera.delta_y * camera.sensitivity;
                camera.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.pitch));
                camera.delta_x = 0.0;
                camera.delta_y = 0.0;
            }

            const front = vec3.fromValues(
                Math.cos(camera.yaw) * Math.cos(camera.pitch),
                Math.sin(camera.pitch),
                Math.sin(camera.yaw) * Math.cos(camera.pitch)
            );

            camera.front = vec3.normalize(camera.front, front);

            const viewMatrix = mat4.lookAt(mat4.create(), camera.position,
                vec3.add(vec3.create(), camera.position, camera.front),
                camera.up);

            gl.clearColor(0., 0., 0., 1.0);
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const fieldOfView = 45 * Math.PI / 180;
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();

            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

            const terrainModelMat = mat4.create();

            mat4.translate(terrainModelMat, terrainModelMat, [0.0, 0.0, 0.0]);
            mat4.scale(terrainModelMat, terrainModelMat, [8.0, 4.0, 8.0]);
            mat4.rotate(terrainModelMat, terrainModelMat, Math.PI / 2, [1.0, 0.0, 0.0]);

            // Draw Skybox

            gl.useProgram(skybox.program);

            gl.bindVertexArray(skybox.skybox.vao);

            gl.disable(gl.DEPTH_TEST);

            const skyboxModelMat = mat4.create();
            mat4.translate(skyboxModelMat, skyboxModelMat, camera.position);
            mat4.scale(skyboxModelMat, skyboxModelMat, [50.0, 50.0, 50.0]);
            mat4.rotate(skyboxModelMat, skyboxModelMat, -Math.PI / 8, [1.0, 0.0, 0.0]);
            const skyboxViewMatrix = mat4.create();
            mat4.copy(skyboxViewMatrix, viewMatrix);

            const modelViewMatrix = mat4.create();
            mat4.multiply(modelViewMatrix, skyboxViewMatrix, skyboxModelMat);

            gl.uniformMatrix4fv(skybox.program.info.uModelViewMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(skybox.program.info.uProjectionMatrix, false, projectionMatrix);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, skybox.cubemap.cubemap);
            gl.uniform1i(skybox.program.info.uCubemap, 0);

            gl.drawElements(gl.TRIANGLES, skybox.skybox.n_elements, gl.UNSIGNED_SHORT, 0);

            gl.useProgram(programInfo.program);

            gl.bindVertexArray(buffers.quad_vao);

            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);

            gl.uniformMatrix4fv(programInfo.u_locations.proj_mat, false, projectionMatrix);
            gl.uniformMatrix4fv(programInfo.u_locations.view_mat, false, viewMatrix);
            gl.uniformMatrix4fv(programInfo.u_locations.model_mat, false, terrainModelMat);
            gl.uniform2f(programInfo.u_locations.offset, x_pos, 0.0);
            gl.uniform4fv(programInfo.u_camera_position, camera.position);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, noise_tex);
            gl.uniform1i(programInfo.u_noise_texture, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, grass.texture);
            gl.uniform1i(programInfo.u_texture, 1);

            gl.activeTexture(gl.TEXTURE2);
            gl.bindTexture(gl.TEXTURE_2D, grass_normals.texture);
            gl.uniform1i(programInfo.u_normals_texture, 2);

            gl.activeTexture(gl.TEXTURE3);
            gl.bindTexture(gl.TEXTURE_2D, grass_occlusion.texture);
            gl.uniform1i(programInfo.u_occlusion_texture, 3);

            gl.activeTexture(gl.TEXTURE4);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, skybox.cubemap.cubemap);
            gl.uniform1i(programInfo.u_cube_texture, 4);

            gl.drawArrays(gl.TRIANGLES, 0, buffers.n_triangles * 3);

            gl.disable(gl.CULL_FACE);
            gl.disable(gl.DEPTH_TEST);

            // check for errors
            let error = gl.getError();
            if (error != gl.NO_ERROR) {
                console.log("WebGL error: " + error);
            }

            // update fps counter
            let fps = 1000.0 / delta_time;
            document.getElementById('fps-counter').innerText = `FPS: ${fps.toFixed(2)}`;

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>

</html>