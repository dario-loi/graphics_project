<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a202c;
        }

        #canvas-container {
            width: 75vw;
            height: 100vh;
        }

        #webgl-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #info {
            width: 25vw;
            height: 100vh;
            background-color: #2d3748;
            color: #fff;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #fps-counter {
            font-size: 2rem;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="webgl-canvas"></canvas>
    </div>
    <div id="info" class="flex flex-col justify-center items-center">
        <div id="fps-counter">FPS: 0</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="./common.js"></script>

    <script>
        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert("WebGL 2.0 isn't available in your browser.");
        }

        // enable MSAA

        fbm_drawer = new FBM(gl);

        // backface culling
        // gl.enable(gl.CULL_FACE);

        // Vertex shader program
        const vsSource = `
            attribute vec4 aVertexPosition;
            attribute vec4 aVertexUv;
            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying lowp vec4 vColor;
            varying highp vec2 vUv;

            uniform sampler2D uNoiseSampler;

            void main(void) {

                float h = texture2D(uNoiseSampler, aVertexUv.xy).r;

                // scale the height

                gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aVertexPosition;

                gl_Position.y += h * 5.0 - 2.0;
                vColor = vec4(1.0, 1.0, 1.0, 1.0);
                vUv = aVertexUv.xy;
            }
        `;

        // Fragment shader program
        const fsSource = `
            precision highp float;
            uniform sampler2D uSampler;
            uniform sampler2D uNoiseSampler;
            uniform vec2 uOffset;

            varying lowp vec4 vColor;
            varying highp vec2 vUv;

            void main(void) {

                const float ambient = 0.2;
                float light = min(texture2D(uNoiseSampler, vUv).r + ambient, 1.0);

                gl_FragColor = vColor * texture2D(uSampler, vUv + uOffset) * light;
            }
        `;

        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

        const programInfo = {
            program: shaderProgram,
            attr_locations: {
                v_pos: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                v_uv: gl.getAttribLocation(shaderProgram, 'aVertexUv'),
            },
            u_locations: {
                proj_mat: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                view_mat: gl.getUniformLocation(shaderProgram, 'uViewMatrix'),
                model_mat: gl.getUniformLocation(shaderProgram, 'uModelMatrix'),
                offset: gl.getUniformLocation(shaderProgram, 'uOffset'),
            },
            u_texture: gl.getUniformLocation(shaderProgram, 'uSampler'),
            u_noise_texture: gl.getUniformLocation(shaderProgram, 'uNoiseSampler'),
        };



        // INIT "GLOBALS"

        let chunks = [];
        let last_time = 0.0;

        // DECLARE PERIODIC EVEMTS

        // schema: {name: string, interval: number, func: function}
        lambdas = [
            {
                "name": "spawn_chunks",
                "interval": 2500.0, // ms
                "offset": 0.0, // ms
                "func": function () {
                    console.log("Spawning chunks");
                }
            },
            {
                "name": "despawn_chunks",
                "interval": 2500.0, // ms
                "offset": 1250.0, // ms
                "func": function () {
                    console.log("Despawning chunks");
                }
            },
        ];

        // for each lambda, after offset time, register the lambda to be called every interval time
        // for (let lambda of lambdas) {
        //     setTimeout(function () {
        //         setInterval(lambda.func, lambda.interval);
        //     }, lambda.offset);
        // }

        // DECLARE EVENT LISTENERS

        listeners = [
            {
                "name": "window_resize",
                "exec_first": true,
                "trigger": "resize",
                "func": function () {
                    const displayWidth = canvas.clientWidth;
                    const displayHeight = canvas.clientHeight;

                    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                        canvas.width = displayWidth;
                        canvas.height = displayHeight;
                        gl.viewport(0, 0, canvas.width, canvas.height);
                    }
                }
            }
        ]

        // inject event listeners
        for (let listener of listeners) {
            if (listener.exec_first) {
                listener.func();
            }
            window.addEventListener(listener.trigger, listener.func);
        }

        // PREP NOISE TARGET

        let noise_tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, noise_tex);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            128,
            128,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            null
        );

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);



        // vertices 3
        // uvs 2
        // normals 3
        buffers = gen_quad(gl, 128);

        // RENDER LOOP
        let grass = new ImageTexture2D(gl, "grass.png", {
            wrap_s: gl.REPEAT,
            wrap_t: gl.REPEAT,
            generate_mipmaps: true
        });

        skybox = new Skybox(gl, new Cubemap(gl, [
            "skybox/right.jpg",
            "skybox/left.jpg",
            "skybox/top.jpg",
            "skybox/bottom.jpg",
            "skybox/front.jpg",
            "skybox/back.jpg",
        ]));

        function render() {

            let time = performance.now();
            let delta_time = time - last_time;

            last_time = time;

            x_pos = time / 10000.0;

            fbm_drawer.sample_fbm(
                gl, noise_tex, 42, 128, 128, x_pos, 0.0
            )


            gl.clearColor(0., 0., 0., 1.0);
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const fieldOfView = 45 * Math.PI / 180;
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();

            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

            const terrainModelMat = mat4.create();
            const viewMatrix = mat4.create();


            mat4.translate(terrainModelMat, terrainModelMat, [-2.0, 0.0, 0.0]);
            mat4.scale(terrainModelMat, terrainModelMat, [4.0, 4.0, 4.0]);
            mat4.rotate(terrainModelMat, terrainModelMat, Math.PI / 2, [1.0, 0.0, 0.0]);

            //mat4.rotate(terrainModelMat, terrainModelMat, performance.now() / 2000 * Math.PI, [0.0, 1.0, 0.0]);
            mat4.translate(viewMatrix, viewMatrix, [0.0, 0.0, -14.0]);
            mat4.rotate(viewMatrix, viewMatrix, Math.PI / 6, [1.0, 0.0, 0.0]);

            // Draw Skybox

            gl.useProgram(skybox.program);

            gl.bindVertexArray(skybox.skybox.vao);

            gl.disable(gl.DEPTH_TEST);

            const skyboxModelMat = mat4.create();
            mat4.scale(skyboxModelMat, skyboxModelMat, [50.0, 50.0, 50.0]);
            mat4.rotate(skyboxModelMat, skyboxModelMat, -Math.PI / 8, [1.0, 0.0, 0.0]);
            const skyboxViewMatrix = mat4.create();
            mat4.copy(skyboxViewMatrix, viewMatrix);

            const modelViewMatrix = mat4.create();
            mat4.multiply(modelViewMatrix, skyboxViewMatrix, skyboxModelMat);

            gl.uniformMatrix4fv(skybox.program.info.uModelViewMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(skybox.program.info.uProjectionMatrix, false, projectionMatrix);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, skybox.cubemap.cubemap);
            gl.uniform1i(skybox.program.info.uCubemap, 0);

            gl.drawElements(gl.TRIANGLES, skybox.skybox.n_elements, gl.UNSIGNED_SHORT, 0);

            gl.useProgram(programInfo.program);

            gl.bindVertexArray(buffers.quad_vao);

            gl.uniformMatrix4fv(programInfo.u_locations.proj_mat, false, projectionMatrix);
            gl.uniformMatrix4fv(programInfo.u_locations.view_mat, false, viewMatrix);
            gl.uniformMatrix4fv(programInfo.u_locations.model_mat, false, terrainModelMat);
            gl.uniform2f(programInfo.u_locations.offset, x_pos, 0.0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, noise_tex);
            gl.uniform1i(programInfo.u_noise_texture, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, grass.texture);
            gl.uniform1i(programInfo.u_texture, 1);

            gl.drawArrays(gl.TRIANGLES, 0, buffers.n_triangles * 3);

            // check for errors
            let error = gl.getError();
            if (error != gl.NO_ERROR) {
                console.log("WebGL error: " + error);
            }

            // update fps counter
            let fps = 1000.0 / delta_time;
            document.getElementById('fps-counter').innerText = `FPS: ${fps.toFixed(2)}`;

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>

</html>